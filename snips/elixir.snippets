snippet "@mo(d(ule)?)?" "" r
@moduledoc ${1:"""
${0:${VISUAL}}
"""}
endsnippet

snippet "@doc" ""
@doc ${1:"""
${0:${VISUAL}}
"""}
endsnippet

snippet fn "" w
fn ${1} -> ${2} end
endsnippet

snippet do "" w
do
${0:${VISUAL}}
end
endsnippet

snippet def "" b
def ${1:name${2:(${3})}} do
  ${0:${VISUAL}}
end
endsnippet

snippet defp "" b
defp ${1:name${2:(${3})}} do
  ${0:${VISUAL}}
end
endsnippet

snippet defmo "" b
defmodule ${1:`!v user#snips#elixir_module()`} do
  ${0:${VISUAL}}
end
endsnippet

snippet defpro "" b
defprotocol ${1:Name} do
  ${0:${VISUAL}}
end
endsnippet

snippet case "" w
case ${1} do
  ${0:${VISUAL}}
end
endsnippet

snippet cond "" w
cond ${1} do
  ${0:${VISUAL}}
end
endsnippet

snippet "put(s)?" "" wr
IO.puts${1}
endsnippet

snippet "ins" "" wr
IO.inspect(${0:${VISUAL}}${1:label: ${2::HERE}})${3}
endsnippet

snippet test "" b
test ${1} do
  ${0:${VISUAL}}
end
endsnippet

snippet "des(c(ribe)?)?" "" br
describe ${1} do
  ${0:${VISUAL}}
end
endsnippet

snippet pry
require IEx
IEx.pry
endsnippet

snippet st
Process.info(self(), :current_stacktrace) |> IO.inspect(${1:label: ${2::stacktrace}})
endsnippet
